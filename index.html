<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>주머니 순회</title>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function () {
	const locations = {
		"상인 네루": "티르코네일", "상인 누누": "던바튼", "상인 메루": "이멘마하", "상인 라누": "반호르", "상인 베루": "탈틴", "상인 에루": "타라",
		"상인 아루": "카브", "상인 피루": "벨바스트", "상인 세누": "스카하", "테일로": "켈라", "켄": "필리아", "리나": "코르", "카디": "발레스", 
		"귀넥": "카루", "얼리": "오아시스", "모락": "칼리다", "데위": "페라(자르딘)"
	};

	const setDefinitions = {
		    작물세트: ["튼튼한 달걀 주머니", "튼튼한 감자 주머니", "튼튼한 옥수수 주머니", "튼튼한 밀 주머니", "튼튼한 보리 주머니"],
		    방직세트: ["튼튼한 양털 주머니", "튼튼한 거미줄 주머니", "튼튼한 가는 실뭉치 주머니", "튼튼한 굵은 실뭉치 주머니"],
		    가죽세트: ["튼튼한 저가형 가죽 주머니", "튼튼한 일반 가죽 주머니", "튼튼한 고급 가죽 주머니", "튼튼한 최고급 가죽 주머니"],
		    옷감세트: ["튼튼한 저가형 옷감 주머니", "튼튼한 일반 옷감 주머니", "튼튼한 고급 옷감 주머니", "튼튼한 최고급 옷감 주머니"],
		    실크세트: ["튼튼한 저가형 실크 주머니", "튼튼한 일반 실크 주머니", "튼튼한 고급 실크 주머니", "튼튼한 최고급 실크 주머니"]
		};

	const server_ch = { "울프": 15, "류트": 42, "하프": 24, "만돌린": 15 };
	
	const jumoney_url = "https://api.na.mabibase.com/assets/item/icon/";
	const jumoney_key = [
	  "5110005",
	  "5110006",
	  "5110007",
	  "5110008",
	  "5110009",
	  "5110010",
  	  "2041",
          "2042",
          "2043",
	  "5110014",
	  "5110015",
	  "5110016",
	  "5110017",
	  "5110018",
	  "5110019",
	  "5110020",
	  "5110021",
	  "5110022",
	  "5110023",
	  "5110024",
	  "5110025",
	  "5110044",
	];
	
	let lastResetTime = null;
	let dataCache = {};
	let API_KEY = "";

	// 초기 설정
	setChannel();
	prevNextCh();
	//getNpcData();
	
	window.onload = function () {
		const localApiKey = localStorage.getItem("apiKey");
		if (localApiKey) {
		  document.getElementById("apiKey").value = localApiKey;
		  API_KEY = localApiKey;
		}
		
		const localServer = localStorage.getItem("server");
		const localChannel = localStorage.getItem("channel");
		const localNpc = localStorage.getItem("npc");
		
		if (localServer) 
		  document.getElementById("server").value = localServer;
		
		if (localChannel)
		  document.getElementById("ch").value = localChannel;
		
		if (localNpc)
		  document.getElementById("npc_nm").value = localNpc;		  
	};

	function getLocatioin() {
		const npc_nm = document.getElementById("npc_nm").value;
		return npc_nm === "all" ? Object.keys(locations) : [npc_nm];
	}

	function setChannel() {
		const chSelect = document.getElementById("ch");
		const serverSelect = document.getElementById("server");
		const maxCh = server_ch[serverSelect.value];

		chSelect.innerHTML = "";
		for (let i = 1; i <= maxCh; i++) {
			if (i === 11) continue;
			let option = document.createElement('option');
			option.value = i;
			option.text = `${i}채`;
			chSelect.appendChild(option);
		}
		
		if(API_KEY != "") chSelect.dispatchEvent(new Event('change'));
	}

	async function getNpcData() {
		if(API_KEY == "") {
			alert("API KEY를 입력해주세요");
			return false;
		}
		
		const server_name = document.getElementById("server").value;
		const channel = document.getElementById("ch").value;
		const locations = getLocatioin();

		document.getElementById("tables").innerHTML = "";

		const fetchPromises = locations.map(async (npc) => {
			const cacheKey = `${npc}_${server_name}_${channel}`;
			if (dataCache[cacheKey]) {
				return { data: dataCache[cacheKey], npc };
			} else {
				const urlString = `https://open.api.nexon.com/mabinogi/v1/npcshop/list?npc_name=${npc}&server_name=${server_name}&channel=${channel}`;
				
				try {					
					const response = await fetch(urlString, {
						headers: { "x-nxopen-api-key": API_KEY }
					});
					
					const data = await response.json();
					
					if(data.error) {
						console.warn(`Error: ${data.error.name}: ${data.error.message}`);
						document.getElementById("tables").insertAdjacentHTML('beforeend', `<h3>${data.error.name}<br/>${data.error.message}</h3>`);
						document.getElementById("loading").style.display = "none";
						document.getElementById("tables").style.display = "block";
						controller.abort();  // 모든 fetch 요청 중단
						throw new Error(`HTTP 오류! 상태: ${data.error.name}: ${data.error.message}`);
					}
					dataCache[cacheKey] = data;
					return { data, npc };
					
				} catch (error) {
					//alert(data.error.name + "\n" + data.error.message);
					console.error(`Error fetching NPC data for ${npc}:`, error);
					displayErrorMessage(npc, error.message);
					return null;
				}
			}
		});

		const results = await Promise.all(fetchPromises);
		results.forEach(result => {
			if (result && result.data && result.data.shop) {
				const resetTime = convertToKST(result.data.date_shop_next_update);
				if ( !lastResetTime && lastResetTime != resetTime) {
					lastResetTime = resetTime;  // 리셋 시간을 업데이트
					document.getElementById("time").innerText = resetTime;
				}
				getJumoney(result.data, result.npc);
			} else {				
				const errorMessage = `<h3>${result.data.error.name}<br/>${result.data.error.message}</h3>`;
				document.getElementById("tables").insertAdjacentHTML('beforeend', errorMessage);
				document.getElementById("loading").style.display = "none";
				document.getElementById("tables").style.display = "block";
			}
		});
	}

	function getUrlColor(colors){
		const urlColor = Object.values(colors).slice(0, 3);
	    return urlColor.map(color => '0x' + color.slice(1).toLowerCase()).join('%2C');
	}
	
	function getJumoney(data, npc) {		
		if (!data.shop) {
			alert(data.error.name + "\n" + data.error.message);
			console.warn(`No shop data for NPC: ${npc}`);
			return null;
		}
		
		const items = data.shop.find(item => item.tab_name === "주머니")?.item || [];
		let table = `<h2>${locations[npc]}</h2><div class="container">`;
		let count = 0;
		const max_cnt = 6; //한 열 최대 수

		items.forEach((key, index) => {
			const url = key.image_url;
			const item_nm = key.item_display_name;
			const color = extractItemColorsFromUrl(url);
			
			//if (count % max_cnt === 0) table += "<tr>";
			table += `<div class="item"><img src="${url}" alt="${item_nm}" class="api-img"><img src="${jumoney_url}${jumoney_key[index]}?colors=${getUrlColor(color)}" class="mabibase-img" onerror="this.src='./cute.png'"><label class="item_nm">${item_nm}</label>${setColorLabel(color)}</div>`;
			count++;
			//if (count % max_cnt === 0) table += "</tr>";
		});

		table += "</div>";
		document.getElementById("tables").insertAdjacentHTML('beforeend', table);
		document.getElementById("loading").style.display = "none";
		document.getElementById("tables").style.display = "block";
	}

	function extractItemColorsFromUrl(url) {
		try {
			const urlParams = new URL(url).searchParams;
			const itemColorEncoded = urlParams.get('item_color');
			if (!itemColorEncoded) return null;
			const itemColorDecoded = decodeURIComponent(itemColorEncoded);
			return JSON.parse(itemColorDecoded);
		} catch (error) {
			console.warn('Error extracting item colors:', error);
			return null;
		}
	}

	function setColorLabel(color) {
		if (!color) return '';
		let result = "<div>";
		for (let i = 1; i <= 3; i++) {
			const cur_color = color["color_0" + i];
			result += `<p><span class="color_rect" style="background:${cur_color};"></span><label class="hex">${cur_color}</label><label class="rgb">${hexToRgbString(cur_color)}</label></p>`;
		}
		result += "</div>";
		return result;
	}

	function hexToRgbString(hex) {
		const rgb = hexToRgb(hex);
		return `${rgb.r} ${rgb.g} ${rgb.b}`;
	}

	function hexToRgb(hex) {
		const r = parseInt(hex.slice(1, 3), 16);
		const g = parseInt(hex.slice(3, 5), 16);
		const b = parseInt(hex.slice(5, 7), 16);
		return { r, g, b };
	}
	
	// 한국 시간으로 리셋 시간 표시
	function convertToKST(isoDate) {
		const date = new Date(isoDate);
		const options = { 
			timeZone: 'Asia/Seoul', 
			year: 'numeric', 
			month: '2-digit', 
			day: '2-digit', 
			hour: '2-digit', 
			minute: '2-digit', 
			hour12: false 
		};
		const formatter = new Intl.DateTimeFormat('ko-KR', options);
		const parts = formatter.formatToParts(date);
		const dateStr = parts.filter(part => part.type === 'year' || part.type === 'month' || part.type === 'day')
						   .map(part => part.value).join('-');
		const timeStr = parts.filter(part => part.type === 'hour' || part.type === 'minute')
						   .map(part => part.value).join(':');
		return `${dateStr} ${timeStr}`;
	}

	// 서버 변경 시 채널 목록 재설정
	document.getElementById("server").addEventListener("change", function() {
		const server = this.value; // 선택한 서버 가져오기
		localStorage.setItem("server", server); // 로컬 스토리지에 저장
	  	setChannel();
	});
	
	document.getElementById("npc_nm").addEventListener("change", function() {
		const npc = this.value; // 선택한 서버 가져오기
	  	localStorage.setItem("npc", npc); // 로컬 스토리지에 저장
		getNpcData();
	});
	
	document.getElementById("ch").addEventListener("change", getNpcData);
	document.getElementById("setApiKey").addEventListener("click", function() {
		API_KEY = document.getElementById("apiKey").value;
		getNpcData();
	});
	
	// API 키 입력 필드에 이벤트 리스너 추가
	document.getElementById("apiKey").addEventListener("input", function() {
	  const apiKey = this.value; // 입력값 가져오기
	  localStorage.setItem("apiKey", apiKey); // 로컬 스토리지에 저장
	});

	// 채널 입력 필드에 이벤트 리스너 추가
	document.getElementById("ch").addEventListener("input", function() {
	  const channel = this.value; // 입력값 가져오기
	  localStorage.setItem("channel", channel); // 로컬 스토리지에 저장
	});	


	// 채널 전환 버튼
	function prevNextCh() {
		const selectBox = document.getElementById('ch');
		const prevButton = document.getElementById('prev');
		const nextButton = document.getElementById('next');

		prevButton.addEventListener('click', function () {
			selectBox.selectedIndex = selectBox.selectedIndex === 0 ? selectBox.options.length - 1 : selectBox.selectedIndex - 1;
			selectBox.dispatchEvent(new Event('change'));
		});

		nextButton.addEventListener('click', function () {
			selectBox.selectedIndex = selectBox.selectedIndex === selectBox.options.length - 1 ? 0 : selectBox.selectedIndex + 1;
			selectBox.dispatchEvent(new Event('change'));
		});
	}
	
	document.getElementById("checkSet").addEventListener("click", async function () {
	    alert("준비중 입니다.", function(){
	    	return false;
	    });
	    
		const npc_nm = document.getElementById("npc_nm").value;
	    if (npc_nm === "all") {
	        alert("전체 선택 시 세트 확인이 불가능합니다.");
	        return;
	    }

	    const itemsWithChannels = await fetchAllChannelData();
	    const setsFound = findMatchingSets(itemsWithChannels);
	    displaySetsWithChannels(setsFound);
	});
	
	async function fetchAllChannelData() {
	    const npc_nm = document.getElementById("npc_nm").value;
	    const server_name = document.getElementById("server").value;
	    const maxCh = server_ch[server_name];

	    const promises = [];
	    for (let i = 1; i <= maxCh; i++) {
	        if (i !== 11) promises.push(fetchChannelData(npc_nm, server_name, i));
	    }

	    const results = await Promise.all(promises);
	    return results.flat();
	}

	async function fetchChannelData(npc_nm, server_name, channel) {
	    const url = `https://open.api.nexon.com/mabinogi/v1/npcshop/list?npc_name=${npc_nm}&server_name=${server_name}&channel=${channel}`;

	    try {
	        const response = await fetch(url, { headers: { "x-nxopen-api-key": API_KEY } });
	        const data = await response.json();
	        const items = data.shop.find(item => item.tab_name === "주머니")?.item || [];
	        return items.map(item => ({ ...item, channel }));  // 채널 정보 포함
	    } catch (error) {
	        console.error(`채널 ${channel} 데이터 불러오기 실패:`, error);
	        return [];
	    }
	}

	function findMatchingSets(items) {
	    const setsFound = {};

	    Object.entries(setDefinitions).forEach(([setName, setItems]) => {
	        const matchingItems = setItems.map(setItem =>
	            items.find(item => item.item_display_name === setItem)
	        ).filter(Boolean);

	        if (matchingItems.length === setItems.length) {
	            const firstPalette = extractRelevantColors(matchingItems[0].image_url);

	            const isMatchingPalette = matchingItems.every(item =>
	                extractRelevantColors(item.image_url) === firstPalette
	            );

	            if (isMatchingPalette) {
	                if (!setsFound[setName]) setsFound[setName] = { colors: firstPalette, items: [] };

	                matchingItems.forEach(item => {
	                    setsFound[setName].items.push({
	                        name: item.item_display_name,
	                        channel: item.channel
	                    });
	                });
	            }
	        }
	    });

	    return setsFound;
	}

	function extractRelevantColors(url) {
	    try {
	        const params = new URL(url).searchParams;
	        const colors = JSON.parse(decodeURIComponent(params.get('item_color') || '{}'));
	        return `${colors.color_01}-${colors.color_02}-${colors.color_03}`;  // 색상 팔레트를 문자열로 변환
	    } catch (error) {
	        console.warn("색상 추출 오류:", error);
	        return "";
	    }
	}

	function displaySetsWithChannels(sets) {
	    const setsContainer = document.getElementById("sets");
	    setsContainer.innerHTML = "";

	    if (!sets || Object.keys(sets).length === 0) {
	        setsContainer.insertAdjacentHTML('beforeend', "<p>세트를 찾을 수 없습니다.</p>");
	        return;
	    }

	    let html = "<h3>세트 정보</h3>";
	    Object.entries(sets).forEach(([setName, { colors, items }]) => {
	        html += `<h4>${setName}</h4>`;
	        html += `<p>색상: ${colors}</p><ul>`;  // 색상은 한 번만 출력

	        items.forEach(({ name, channel }) => {
	            html += `<li>${name} (채널: ${channel})</li>`;
	        });

	        html += "</ul>";
	    });

	    setsContainer.insertAdjacentHTML('beforeend', html);
	}

});

</script>

<style>
body {
	display: grid;
   	justify-items: center;
}
#main {
    /*width: calc(240px* 6 + 35px);*/
    width: 100%;
    max-width: calc(240px* 6 + 35px);
    text-align: center;
}
.api-img {
	width: 60%;
}
.item {
    width: calc(100% - 6px);
    min-width: 235px;
    border: 1px solid #e1e1e1;
    vertical-align: top;
    text-align: center;
    margin-bottom: 4px;
}
.color_rect {
    display: inline-block;
    width: 15px;
    height: 15px;
    margin: 0px 8px;
    border: 1px solid #999;
    border-radius: 3px;
}
label {
	display: inline-block;
    line-height: 15px;
    vertical-align: top;
    font-size: 14px;
}
label.hex {
	width: calc(50% - 40px);
    margin-right: 5px;
}
label.rgb {
	width: calc(50% - 20px);
    float: right;
    text-align: left;
}
div {
    text-align: left;
    width: 90%;
    display: inline-block;
}
p {
    margin: 2px;
    text-align: left;
    display: flex;
    justify-content: space-evenly;
}
.item_nm {
	margin-bottom: 7px;
	display: block;
}

#srchForm {
    text-align: center;
    width: calc(100% - 20px);
    position: fixed;
    left: 0;
    right: 0;
    margin: auto;
    background: #fff;
    top: 0;
    padding: 10px 10px;
    box-shadow: 0 3px 6px 0px #b3b3b3;
    height: 80px;
    z-index: 1;
}
#wid{
    width: 100%;
    max-width: 1435px;
    position: relative;
    text-align: right;
}
#resetTime {
    position: absolute;
    left: 0px;
    top: 50%;
    transform: translate(0%, -50%);
}
#resetTime #time {
	border: 0px;
	width: 150px;
	background: transparent;
}
#loading {
    width: 100%;
    padding: 100px 0px;
    text-align: center;
}
select {
    border-color: #cccccc;
    border-radius: 3px;
    padding: 5px;
    font-size: 15pt;
}
#tables {
	width:100%;
	margin-top: 110px;
}
h2{
    margin: 0px;
    margin-top: 20px;
}
.container{
    display: grid;
    width: 100%;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
}
.img {
	height: 60%;
}
button {
    padding: 7px;
    font-size: 1em;
    vertical-align: bottom;
    border: 1px solid #38416f;
    background: rgb(83 103 134);
    color: #fff;
    font-weight: normal;
    border-radius: 5px;
    cursor: pointer;
}
button:hover, button:active {
    background: rgb(59 76 103);
    transform: translateY(1px);
    box-shadow: none;
}
.mabibase-img{
	position: relative;
	top: -5%;
}
#top-info{
	width: 100%;
    max-width: 1435px;
    position: relative;
    text-align: right;
    margin-bottom: 10px;
}
#apiKey{
	padding: 5px;
    font-size: 13pt;
    width: 50%;
    text-align: left;
    color: #888;
    margin-right: 5px;
    cursor: pointer;
}
</style>

</head>
<body>
	<div id="main">
		<div id="srchForm">
			<div id="top-info">
				<input type="text" id="apiKey"><button id="setApiKey">적용</button>
				<button onclick="window.open('https://openapi.nexon.com/my-application/')">API KEY 생성</button>
			</div>
			<div id="wid">
				<span id="resetTime">
					리셋 시간: <span type="text" id="time"></span>
				</span>
			
				<select id="npc_nm" class="">
					<option value="all">전체</option>
					<option value="상인 네루">티르코네일</option>
					<option value="상인 누누">던바튼</option>
					<option value="상인 메루">이멘마하</option>
					<option value="상인 라누">반호르</option>
					<option value="상인 베루">탈틴</option>
					<option value="상인 에루">타라</option>
					<option value="상인 아루">카브</option>
					<option value="상인 피루">벨바</option>
					<option value="상인 세누">스카하</option>
					<option value="테일로">켈라</option>
					<option value="켄">필리아</option>
					<option value="리나">코르</option>
					<option value="카디">발레스</option>
					<option value="귀넥">카루</option>
					<option value="얼리">오아시스</option>
					<option value="모락">칼리다</option>
					<option value="데위">페라(자르딘)</option>
				</select>
				
				<select id="server">
					<option value="울프">울프</option>
					<option value="류트">류트</option>
					<option value="하프">하프</option>
					<option value="만돌린">만돌린</option>
				</select>
				
				<select id="ch" class="">
				</select>
				
				<button id="prev">이전 채널</button>
			    <button id="next">다음 채널</button>
			    <button id="checkSet">세트 확인</button>
				
			</div>
		</div>
		<div id="loading">...</div>
		<div id="tables" style="display:none;"></div>
		<div id="sets" style="margin-top: 20px;"></div>
	</div>
</body>
</html>
